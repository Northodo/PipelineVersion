/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module pc(clk, rst, stall, din, dout);
	input clk, rst, stall;
	input [31:0] din;
	output [31:0] dout;

	reg [31:0] dout;

	always @(posedge clk)
	begin
		if(rst)
			dout = 0;
		else if(~stall)
			dout = din;
	end
endmodule

module pc (
  input clk,
  input rst,
  input [31:0] din,
  input stall,
  output [31:0] dout
);
  // pc
  pc pc_i0 (
    .clk( clk ),
    .rst( rst ),
    .stall( stall ),
    .din( din ),
    .dout( dout )
  );
endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module data (
  input [31:0] addr,
  input clk,
  input we,
  input [31:0] din,
  input [2:0] func3,
  output [31:0] dout
);
  wire [1:0] s0;
  wire [9:0] s1;
  wire [19:0] s2;
  wire s3;
  wire s4;
  wire [31:0] s5;
  wire [1:0] s6;
  wire [31:0] s7;
  wire [31:0] s8;
  wire s9;
  wire [7:0] s10;
  wire [7:0] s11;
  wire [7:0] s12;
  wire [7:0] s13;
  wire [7:0] s14;
  wire [31:0] s15;
  wire [31:0] s16;
  wire s17;
  wire [15:0] s18;
  wire [15:0] s19;
  wire [15:0] s20;
  wire [31:0] s21;
  wire [31:0] s22;
  assign s0 = addr[1:0];
  assign s1 = addr[11:2];
  assign s2 = addr[31:12];
  assign s6 = func3[1:0];
  assign s9 = func3[2];
  CompUnsigned #(
    .Bits(20)
  )
  CompUnsigned_i0 (
    .a( s2 ),
    .b( 20'b0 ),
    .\= ( s3 )
  );
  assign s17 = s0[1];
  assign s4 = (we & s3);
  DIG_RAMDualPort #(
    .Bits(32),
    .AddrBits(10)
  )
  DIG_RAMDualPort_i1 (
    .A( s1 ),
    .Din( din ),
    .str( s4 ),
    .C( clk ),
    .ld( s3 ),
    .D( s5 )
  );
  assign s10 = s5[7:0];
  assign s11 = s5[15:8];
  assign s12 = s5[23:16];
  assign s13 = s5[31:24];
  assign s18 = s5[15:0];
  assign s19 = s5[31:16];
  Mux_4x1_NBits #(
    .Bits(8)
  )
  Mux_4x1_NBits_i2 (
    .sel( s0 ),
    .in_0( s10 ),
    .in_1( s11 ),
    .in_2( s12 ),
    .in_3( s13 ),
    .out( s14 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i3 (
    .sel( s17 ),
    .in_0( s18 ),
    .in_1( s19 ),
    .out( s20 )
  );
  DIG_BitExtender #(
    .inputBits(8),
    .outputBits(32)
  )
  DIG_BitExtender_i4 (
    .in( s14 ),
    .out( s15 )
  );
  assign s16[7:0] = s14;
  assign s16[31:8] = 24'b0;
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i5 (
    .in( s20 ),
    .out( s21 )
  );
  assign s22[15:0] = s20;
  assign s22[31:16] = 16'b0;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i6 (
    .sel( s9 ),
    .in_0( s15 ),
    .in_1( s16 ),
    .out( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i7 (
    .sel( s9 ),
    .in_0( s21 ),
    .in_1( s22 ),
    .out( s8 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i8 (
    .sel( s6 ),
    .in_0( s7 ),
    .in_1( s8 ),
    .in_2( s5 ),
    .in_3( 32'b0 ),
    .out( dout )
  );
endmodule
module regfile(clk, we, rs1, rs2, rd, din, r1, r2);
	input clk, we;
	input [4:0] rs1, rs2, rd;
	input [31:0] din;
	output [31:0] r1, r2;

	reg [31:0] r[1:31];

	assign r1 = (rs1 == 0)?0:r[rs1];
	assign r2 = (rs2 == 0)?0:r[rs2];

	always @(posedge clk)
	begin
		if(we && rd != 0)
			r[rd] = din;
	end

endmodule

module regfile (
  input clk,
  input we,
  input [4:0] rs1,
  input [4:0] rs2,
  input [4:0] rd,
  input [31:0] din,
  output [31:0] r1,
  output [31:0] r2
);
  // regfile
  regfile regfile_i0 (
    .clk( clk ),
    .we( we ),
    .rs1( rs1 ),
    .rs2( rs2 ),
    .rd( rd ),
    .din( din ),
    .r1( r1 ),
    .r2( r2 )
  );
endmodule
module r(clk, clr, stall, din, dout);
	input clk, clr, stall;
	input [31:0] din;
	output [31:0] dout;
	
	reg [31:0] dout;

	always @(posedge clk)
	begin
		if(clr)
			dout = 0;
		else  if(~stall)
			dout = din;
	end
endmodule

module f_d (
  input clk,
  input flush,
  input stall,
  input [63:0] din,
  output [31:0] dout
);
  // r
  r r_i0 (
    .clk( clk ),
    .clr( flush ),
    .stall( stall ),
    .din( din ),
    .dout( dout )
  );
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module \pc+4  (
  input [31:0] pc,
  output [31:0] pc4
);
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( pc ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( pc4 )
  );
endmodule
